"""
AI-Powered Documentation Generator for the Ultimate Lyra Trading System.

This script uses the analysis results to generate comprehensive documentation for the codebase.
"""

import json
import os
from pathlib import Path

class DocumentationGenerator:
    def __init__(self):
        self.analysis_dir = "/home/ubuntu/ai_analysis_results"
        self.codebase_path = "/home/ubuntu/github_push_staging"
        self.docs_output_dir = "/home/ubuntu/generated_documentation"
        self.structure_analysis = None
        self.detailed_analysis = None

        os.makedirs(self.docs_output_dir, exist_ok=True)

    def load_analysis_results(self):
        """Load the analysis results from the JSON files."""
        try:
            with open(os.path.join(self.analysis_dir, "structure_analysis.json"), "r") as f:
                self.structure_analysis = json.load(f)
            
            # Wait for the detailed analysis to complete
            detailed_analysis_path = os.path.join(self.analysis_dir, "detailed_analysis.json")
            if os.path.exists(detailed_analysis_path):
                 with open(detailed_analysis_path, "r") as f:
                    self.detailed_analysis = json.load(f)
            else:
                print("Warning: detailed_analysis.json not found. Documentation will be less detailed.")

        except FileNotFoundError as e:
            print(f"Error: Analysis file not found - {e}. Please run the analysis scripts first.")
            return False
        return True

    def generate_main_readme(self):
        """Generate the main README.md file for the project."""
        if not self.structure_analysis:
            return

        readme_content = """
# Ultimate Lyra Trading System - Comprehensive Documentation

This repository contains the complete codebase for the Ultimate Lyra Trading System, an AI-powered autonomous trading ecosystem. This documentation was automatically generated by an AI assistant to provide a comprehensive overview of the project.

## Project Overview

*   **Total Files:** {total_files}
*   **Total Codebase Size:** {total_size_mb} MB
*   **Average File Size:** {average_file_size_kb} KB

## Codebase Structure

"""
        readme_content = readme_content.format(**self.structure_analysis["summary"])

        # Add file categories
        readme_content += "### File Categories\n\n"
        readme_content += "| Category | Number of Files |\n"
        readme_content += "|---|---|\n"
        for category, count in self.structure_analysis["categories"].items():
            readme_content += f"| {category} | {count} |\n"

        # Add top file types
        readme_content += "\n### Top File Types\n\n"
        readme_content += "| Extension | Number of Files |\n"
        readme_content += "|---|---|\n"
        for ext, count in self.structure_analysis["file_types"].items():
            readme_content += f"| {ext or 'no extension'} | {count} |\n"
        
        # Add directory structure
        readme_content += "\n### Directory Structure\n\n```\n"
        for directory in sorted(self.structure_analysis["directory_structure"].keys()):
            readme_content += f"{directory}/\n"
        readme_content += "```\n"

        # Save the main README
        with open(os.path.join(self.docs_output_dir, "README.md"), "w") as f:
            f.write(readme_content)

        print("Generated main README.md")

    def generate_directory_readmes(self):
        """Generate README.md files for each directory."""
        if not self.structure_analysis:
            return

        for directory, files in self.structure_analysis["directory_structure"].items():
            dir_path = os.path.join(self.docs_output_dir, directory)
            os.makedirs(dir_path, exist_ok=True)

            readme_content = f"# Directory: {directory}\n\n"
            readme_content += f"This directory contains {len(files)} files.\n\n"
            readme_content += "## Files in this Directory\n\n"

            for file in sorted(files):
                readme_content += f"*   `{file}`\n"

            # Add detailed file analysis if available
            if self.detailed_analysis:
                readme_content += "\n## Detailed File Analysis\n\n"
                for file_analysis in self.detailed_analysis:
                    if os.path.basename(file_analysis["file_path"]) in files:
                        readme_content += f"### `{os.path.basename(file_analysis['file_path'])}`\n\n"
                        readme_content += f"*   **Category:** {file_analysis.get('category', 'N/A')}\n"
                        readme_content += f"*   **Summary:** {file_analysis.get('summary', 'N/A')}\n"
                        readme_content += f"*   **Quality Rating:** {file_analysis.get('quality_rating', 'N/A')}/10\n"
                        readme_content += f"*   **Suggestions:**\n"
                        for suggestion in file_analysis.get('suggestions', []):
                            readme_content += f"    *   {suggestion}\n"
                        readme_content += "\n"

            with open(os.path.join(dir_path, "README.md"), "w") as f:
                f.write(readme_content)
            
            print(f"Generated README.md for {directory}/")

    def run(self):
        """Run the documentation generation process."""
        if self.load_analysis_results():
            self.generate_main_readme()
            self.generate_directory_readmes()
            print("\nâœ… Documentation generation complete!")

if __name__ == "__main__":
    generator = DocumentationGenerator()
    generator.run()

