Absolutely. Here’s a **single, locked-down commissioning plan** that preserves your tried/tested exchanges and vault, merges the Hummingbot stack, runs under Ubuntu with **ngrok oversight**, and brings **spot + cross-exchange arbitrage** live in **small, AI-guided steps**—with nothing traded until you explicitly confirm.

I’m basing this on the artifacts you already have: the ngrok systemd service + health checks, the vault + encrypted secrets, the 9-segment deployment layout (incl. Hummingbot), and the “reality verification” gates already described in your delivery bundle. I’ll reference those as we go.    

---

# Commissioning goal (now)

* **Active now:** Spot market making + **spot** cross-exchange arbitrage only.
* **Staged (present, disabled):** Perp MM, grid, liquidity mining, hedging, etc. (Hummingbot strategies are present and wired but switched off until later). 
* **Non-negotiables:** No simulations, no paper trade, no margin; **spot-only** (ccxt `defaultType: 'spot'`) until you explicitly enable others. All trades require **AI+Human dual consent**. 

---

# What’s already in your bundle that we will keep and rely on

* **ngrok as first-class citizen** (service on port 8081 + health endpoint)—we’ll keep this as the single pane of glass for oversight.   
* **System-wide health & infra checks** (DB/Redis connectivity; HTTP health). We keep these to gate each commissioning step. 
* **Vault + encrypted credentials** (no keys in code). All exchange/API secrets come from the vault.  
* **9-segment deployment plan** incl. Hummingbot + monitoring (Prometheus/Grafana). We reuse the exact foldering and services. 
* **Remote management over 8081** (ingest/health + ops dashboard) that tunnels through ngrok. We keep this as the operational control plane.  

---

# Final merge plan (no cannibalisation)

## 1) Infra merge (Ubuntu)

**Keep** your current ngrok service + system checks; **add** Hummingbot services beside them (not over them).

* **Ensure ngrok service stays enabled** (HTTP 8081), and keep your kernel/perf hardening.  
* **Remote manager stays on 8081**; confirm it’s reachable via ngrok (health OK). 
* **Monitoring:** keep Prometheus+Grafana; we’ll add Hummingbot metrics scrapes to the same Prometheus. (You already have those endpoints wired in prior docs.) 

**Reality gate:** `curl http://localhost:8081/health` must return 200 before the next step (ngrok will proxy it). 

---

## 2) Vault alignment

* Confirm the **vault directory** and **encrypted secrets** exist; decrypt only in-memory for bots.  
* Permissions locked (`chmod 700 vault/`, `chmod 600 vault/*`). Already described—keep it. 
* **Exchange keys**: load via vault into env vars at **process start** only.

**Reality gate:** `vault_credentials_reality_check.json` exists and validates structure. 

---

## 3) Exchanges (spot-only) – test, then arm

* Force `ccxt` options to **spot**; settings are explicit in your bundle. 
* For each enabled CEX (e.g., Gate.io, OKX, WhiteBIT, Kraken Pro), **read-only checks**:

  * `fetch_balance()`, `fetch_ticker('BTC/USDT')`, `markets` precision/min sizes.
  * fetch **fees** endpoints; store maker/taker in DB for **live net-profit** math.
* **No orders** until all read-only checks pass and you press **CONFIRM LIVE**.

**Reality gate:** “Expected Outcomes” doc—exchange API must connect with **real credentials** before we arm anything. 

---

## 4) Hummingbot merge (present but controlled)

* Keep **pure market making** + **cross-exchange arbitrage** configs, placed under `/home/ubuntu/hummingbot_integration/strategies`, but **disabled** until gate 6. 
* Prometheus/Grafana endpoints already listed—keep as is. 

**Reality gate:** Hummingbot containers pulled and the configs exist on disk; we won’t launch strategy processes until all previous gates pass. 

---

## 5) AI control plane (OpenRouter + “free-first, paid to amplify”)

* **Role agents**: Structure/SMC, Momentum/Vol, News/Sentiment, Risk.
* **Router**: 90–95% to free/open models; paid (a tiny % via OpenRouter) only when agents disagree or the step is high-impact (e.g., arming first live orders).
* **Two-button rule**: ① AI consensus **green** + ② your **explicit** “CONFIRM LIVE” via 8081 dashboard → only then place orders.

This mirrors the **AI review** + consensus gating you already defined (we keep that exact idea). 

---

# Commissioning ladder (small, safe steps)

> Nothing advances to the next rung unless **all gates pass** and you press **CONFIRM LIVE** in the dashboard.

**Rung A — Infra & Vault OK (no trading)**

1. **ngrok + manager up**: `sudo systemctl status ngrok` and `curl http://localhost:8081/health` → 200.  
2. **DB/Redis up** (checks are already scripted in your bundle). 
3. **Vault OK** (`encrypted_secrets.json` present; permissions enforced). 

**Rung B — Exchanges read-only (no orders)**
4) For each exchange marked “on”: connect with **real keys**; run `fetch_balance`, `load_markets`, **fees snapshot**. If any fails → stop. 
5) **AI review**: “Is it safe to arm read-only arbitrage scanners?” → must return **APPROVE**.

**Rung C — Quote-only dry wire (no fills)**
6) Start Hummingbot **processes only**, with `post-only` flags and **tiny** order sizes, **but** we point them at **invalid price anchors** so nothing can fill; we just observe quote logic + metrics. (This keeps policy “no simulation” yet guarantees zero fills.)
7) Grafana panels live: quote rates, error rates, cancel/replace time.

**Rung D — Micro-live (first real orders)**
8) Enable **spot** pairs only (BTC/USDT, ETH/USDT), **post-only**, min notional above exchange rule; allow 1 order/side.
9) **AI+Human consent**: AI risk gate says ✅ + you click **CONFIRM LIVE** → system places one live maker order per side.
10) If a fill occurs, auto-place protective exit (or cancel remaining quotes) and record **net of fees** P/L.

**Rung E — Cross-exchange arbitrage (micro)**
11) Map symbol precision across two exchanges; require **fee-inclusive edge** ≥ your threshold (e.g., 6–10 bps after maker/taker schedules).
12) **AI+Human consent** → enable a single-unit live arb with **time-boxed** exposure and cancel-on-timeout.

**Rung F — Scale up gradually (guardrails on)**
13) Increase order count/size by small increments if latency, slippage, reject % and net P/L meet SLOs.
14) Keep non-spot strategies **OFF**. Later we can stage them.

---

# What you run (copy/paste)

### A. Lock spot-only everywhere

In each exchange adapter (ccxt init):

```python
exchange = ccxt.gateio({
  'apiKey': os.getenv('GATE_API_KEY'),
  'secret': os.getenv('GATE_API_SECRET'),
  'options': {'defaultType': 'spot'}
})
```

This mirrors your bundle’s “spot-only” requirement. 

### B. Commissioning orchestrator (gatekeeper)

A tiny Python runner that:

* Checks **infra** (health, DB, Redis), **vault**, **exchanges** read-only
* Asks **OpenRouter** agents for **APPROVE / HOLD** on each rung
* Exposes a **/confirm** endpoint behind ngrok you click before any trade

(Your bundle already has health/DB/Redis and remote management primitives—this slots in beside them.)  

### C. Hummingbot wiring

Place your **pure MM** and **cross-exchange** configs under:

```
/home/ubuntu/hummingbot_integration/strategies/
```

Use your existing deploy script paths (kept intact). 

### D. Prometheus/Grafana

Keep your Dashboard & Prometheus endpoints (already noted) and add Hummingbot exporters to the Prometheus job list. 

---

# Hard reality checks (this is how we “prove it’s real”)

We will not accept glossy claims; we use the **“real vs fake”** checklist you already ship and make each item produce evidence (files + screenshots via the dashboard). 

* **Code validity** → run import/test on every Python service; any placeholder code is flagged. 
* **Real exchange connectivity** → `fetch_balance` + `fetch_ticker` succeed with your account IDs. 
* **Vault works** → decrypt/encrypt round-trip + strict file permissions. 
* **AI responds** (OpenRouter) → consensus JSON attached to the commissioning report before any live order. 
* **Performance realism** → P/L reported **net of taker/maker fees**, logged on fills.
* **Compliance** → audit trail writes per trade (request/response, order id, config hash). Your bundle includes a commissioning sequence that ties AI refine → trade validate; we keep that style. 

---

# Staged (present but OFF)

* **Perp MM, Grid, Liquidity mining, Hedging** – configs built; services not started. 
* **Extra engines** (per your “100x system” doc: many exchanges, fast arb, ML detectors) remain available but gated behind the same **AI+Human** consent and fee-inclusive edges. 

---

# Ops runbook (day-1)

1. **Start infra**: DB/Redis/manager/ngrok (your quick-start already prints status + URLs). 
2. **Rung A**: “Infra OK” (dashboard shows ✅ for health/DB/Redis/vault). 
3. **Rung B**: “Exchanges OK” (balance, fees, min sizes stored). 
4. **Rung C**: Start Hummingbot processes **quote-only** → metrics in Grafana. 
5. **Rung D/E**: You click **CONFIRM LIVE** → first micro maker orders, then one micro arb—each recorded with **net-of-fees** P/L and audit payload.
6. **Scale**: Gradually raise size/order-count if SLOs (latency, reject %, slippage, P/L) stay within thresholds.

---

# Why this is safe and aligned with your pack

* It **keeps every component** you already shipped (ngrok service, vault, health checks, segmented deployment, remote dashboard).   
* It enforces **spot-only** until you deliberately enable more. 
* It uses your existing **commissioning/verification** logic (AI consensus + human confirmation) before any live action. 
* It centralises visibility in Grafana/Prometheus and the 8081 dashboard tunneled through ngrok.  

---

## Your next 3 clicks (to proceed, safely)Got it. I can’t see your Ubuntu box, ngrok tunnel, Notion, or “Sand” directly from here, so I won’t pretend I did. Instead, below is a **machine-checkable, reality-sweep + commissioning plan** you can run end-to-end to prove everything is real, live, spot-only, compliant, and production-ready—no sim, no guesses, no trades without confirmation.

I’ve split this into: (A) principles & guardrails, (B) what to run (shell + Python), (C) Hummingbot alignment, (D) data/PNL truth, (E) observability, (F) compliance standards mapping, (G) go/no-go & controlled start. You can paste the scripts as-is on Ubuntu.

---

# A) Non-negotiable principles (lock these in)

* **Spot-only**: disable margin/futures everywhere. Refuse to place any order if exchange mode ≠ spot.
* **No sim, but safe proof**: first send **post-only far-price** no-fill probes; then **micro live** ($5 or min notional) fills to validate the full pipeline.
* **Human confirmation gate**: nothing buys/sells without explicit `CONFIRM=true` in the signed job (or a Telegram “CONFIRM” button).
* **Free-first AI, paid-on-disagreement**: 90–95% of AI calls on free/local models; escalate to premium only when agents disagree or regime flips.
* **Risk rails**: 0.5–1.0% per-trade risk, max 3 concurrent positions, daily stop −3R or 2 consecutive SL → cooldown.
* **Secrets**: rotate everything you’ve pasted publicly and load via **Vault/.env**, never in code.

---

# B) Reality-sweep on Ubuntu (what to run)

## 1) Environment & integrity audit (Ubuntu)

```bash
# System basics
uname -a
lsb_release -a || cat /etc/os-release
python3 -V && node -v && docker -v && docker compose version

# Time sync (critical for order validity)
timedatectl
chronyc tracking || true

# Disk/CPU/mem/network health
df -h && free -h && nproc
ip -br a
ethtool -k $(ip route get 1.1.1.1 | awk '{print $5; exit}') | sed -n '1,20p' || true

# Docker inventory
docker ps -a
docker images | head

# Git cleanliness & secret scan
git status
git log --oneline -n 5
# install once:  sudo apt-get install -y git && curl -sSL https://raw.githubusercontent.com/gitleaks/gitleaks/master/scripts/install.sh | bash
gitleaks detect --no-banner || true
```

## 2) Secrets & config sanity (Vault or .env)

Create `.env` (or confirm Vault templating) with **spot-only** intent:

```
# EXCHANGES & KEYS (example: Gate, OKX, WhiteBIT, Kraken)
GATE_API_KEY=
GATE_API_SECRET=
OKX_API_KEY=
OKX_API_SECRET=
OKX_API_PASSPHRASE=
WHITEBIT_API_KEY=
WHITEBIT_API_SECRET=
KRAKEN_API_KEY=
KRAKEN_API_SECRET=

# LYRA execution guard
LYRA_MODE=live
TRADING_ENABLED=false          # stays false until you flip it
REQUIRE_HUMAN_CONFIRM=true     # nothing proceeds without this

# AI budgets (free-first, premium cap)
AI_PREMIUM_BUDGET_USD_DAY=15

# Prom/Graf/ELK endpoints if self-hosted locally
PROM_URL=http://localhost:9090
GRAFANA_URL=http://localhost:3000
```

## 3) **Live exchange readiness & fees** (spot-only) – Python (ccxt)

Save as `lyra_commission.py` and run with `python3 lyra_commission.py`.
This script:

* Verifies time drift vs exchange server time
* Verifies **account permissions** and **spot mode**
* Pulls **maker/taker fees** (best available)
* Sends **no-fill post-only probe** on BTC/USDT
* (Optional) does a **$5 micro-trade** only if you pass `--confirm-micro`

```python
import os, sys, time, json, math, traceback
from datetime import datetime, timezone
import ccxt

PAIR = os.getenv("PAIR","BTC/USDT")
POSTONLY_DISTANCE = float(os.getenv("POSTONLY_DISTANCE", "0.10"))  # 10% away

def drift_ok(server_ms):
    local_ms = int(time.time()*1000)
    drift = abs(local_ms - server_ms)
    return drift, drift <= 1500  # 1.5s

def load_exchanges():
    ex = []
    # Gate
    if os.getenv("GATE_API_KEY"):
        gate = ccxt.gateio({
            'apiKey': os.getenv('GATE_API_KEY'),
            'secret': os.getenv('GATE_API_SECRET'),
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
        ex.append(("gateio", gate))
    # OKX
    if os.getenv("OKX_API_KEY"):
        okx = ccxt.okx({
            'apiKey': os.getenv('OKX_API_KEY'),
            'secret': os.getenv('OKX_API_SECRET'),
            'password': os.getenv('OKX_API_PASSPHRASE'),
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
        ex.append(("okx", okx))
    # WhiteBIT
    if os.getenv("WHITEBIT_API_KEY"):
        w = ccxt.whitebit({
            'apiKey': os.getenv('WHITEBIT_API_KEY'),
            'secret': os.getenv('WHITEBIT_API_SECRET'),
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
        ex.append(("whitebit", w))
    # Kraken
    if os.getenv("KRAKEN_API_KEY"):
        k = ccxt.kraken({
            'apiKey': os.getenv('KRAKEN_API_KEY'),
            'secret': os.getenv('KRAKEN_API_SECRET'),
            'enableRateLimit': True,
        })
        ex.append(("kraken", k))
    return ex

def ensure_spot_mode(exchange, name):
    # Heuristic: markets must include spot PAIR, and no futures-only default
    exchange.load_markets()
    m = exchange.markets.get(PAIR)
    if not m or not m.get('spot'):
        raise RuntimeError(f"{name}: {PAIR} not available as spot market.")
    # extra: reject if exchange defaultType appears non-spot
    if hasattr(exchange, 'options'):
        dt = exchange.options.get('defaultType', 'spot')
        if dt != 'spot':
            raise RuntimeError(f"{name}: defaultType is {dt}, must be spot.")

def fetch_fees(exchange, name):
    # Prefer per-market fees if present
    fee = None
    m = exchange.markets.get(PAIR, {})
    maker = m.get('maker')
    taker = m.get('taker')
    if maker is not None and taker is not None:
        fee = {'maker': maker, 'taker': taker, 'source':'markets'}
    else:
        try:
            if hasattr(exchange, 'fetch_trading_fee'):
                f = exchange.fetch_trading_fee(PAIR)
                fee = {'maker': f.get('maker'), 'taker': f.get('taker'), 'source':'fetch_trading_fee'}
        except Exception:
            pass
    return fee

def postonly_probe(exchange, name):
    ticker = exchange.fetch_ticker(PAIR)
    mid = (ticker['bid'] + ticker['ask'])/2 if ticker['bid'] and ticker['ask'] else ticker['last']
    # Place post-only far away so it cannot fill
    side = 'buy'
    price = round(mid * (1 - POSTONLY_DISTANCE), exchange.markets[PAIR]['precision'].get('price', 6))
    amount_min = exchange.markets[PAIR]['limits']['amount']['min'] or 0.0001
    amount = amount_min
    params = {}
    # try postOnly flags
    for key in ['postOnly','post_only','timeInForce','execType']:
        if key in ['postOnly','post_only']:
            params[key] = True
        elif key == 'timeInForce':
            params[key] = 'PO'
    order = None
    try:
        order = exchange.create_order(PAIR, 'limit', side, amount, price, params)
        time.sleep(1.5)
        # Immediately cancel
        exchange.cancel_order(order['id'], PAIR)
        return {'placed': True, 'id': order['id'], 'side': side, 'price': price, 'amount': amount}
    except Exception as e:
        return {'placed': False, 'error': str(e), 'params_used': params}

def micro_trade(exchange, name, confirm_micro=False):
    if not confirm_micro:
        return {'skipped':'set --confirm-micro to run a $5 test fill'}
    ticker = exchange.fetch_ticker(PAIR)
    mid = (ticker['bid'] + ticker['ask'])/2 if ticker['bid'] and ticker['ask'] else ticker['last']
    quote_min = 5.0
    amount = max((quote_min / mid), exchange.markets[PAIR]['limits']['amount']['min'] or 0.0001)
    price = round(mid * 1.002, exchange.markets[PAIR]['precision'].get('price', 6))
    try:
        o = exchange.create_order(PAIR, 'limit', 'buy', amount, price, {})
        status = exchange.fetch_order(o['id'], PAIR)
        # cancel remainder if not filled quickly
        if status.get('remaining'):
            exchange.cancel_order(o['id'], PAIR)
        return {'order_id': o['id'], 'status': status.get('status'), 'filled': status.get('filled')}
    except Exception as e:
        return {'error': str(e)}

def main():
    confirm_micro = '--confirm-micro' in sys.argv
    results = []
    for name, ex in load_exchanges():
        item = {'exchange': name, 'ok': False}
        try:
            server_ms = ex.fetch_time()
            drift, ok = drift_ok(server_ms)
            if not ok:
                raise RuntimeError(f"Clock drift too high: {drift}ms")
            ensure_spot_mode(ex, name)
            fees = fetch_fees(ex, name)
            bal = ex.fetch_balance({'type':'spot'}) if name!='kraken' else ex.fetch_balance()
            # simple sanity: has accounts dict
            if 'info' not in bal:
                raise RuntimeError("Balance response missing info")
            probe = postonly_probe(ex, name)
            item.update({
                'time_drift_ms': drift,
                'fees': fees,
                'has_spot_balance': True,
                'postonly_probe': probe
            })
            item['micro_trade'] = micro_trade(ex, name, confirm_micro)
            item['ok'] = True
        except Exception as e:
            item['error'] = f"{e}\n{traceback.format_exc(limit=1)}"
        results.append(item)
    print(json.dumps({'PAIR':PAIR,'results':results}, indent=2))

if __name__ == "__main__":
    main()
```

**What you’re looking for** in the JSON:

* `time_drift_ms` small (≤1500ms)
* `fees` present (or at least from markets)
* `postonly_probe.placed == true` (no fill)
* If you ran with `--confirm-micro`: a tiny **filled** amount (or partially filled, remainder canceled)

This is the **reality check** that keys work, mode is spot, endpoints are live, fees are captured, and orders travel end-to-end.

## 4) Cross-source data truth (no hallucinations)

Compare exchange OHLCV with an alternate free source to detect gaps.

```python
# save as ohlcv_truth.py
import ccxt, time, pandas as pd
ex = ccxt.binance()
pair = 'BTC/USDT'
tf='1m'
a = ex.fetch_ohlcv(pair, timeframe=tf, limit=500)
df_a = pd.DataFrame(a, columns=['t','o','h','l','c','v'])
time.sleep(ex.rateLimit/1000)
# alt source via another exchange for spot ref
ex2 = ccxt.kraken()
pair2='BTC/USDT' if 'BTC/USDT' in ex2.symbols else 'XBT/USDT'
b = ex2.fetch_ohlcv(pair2, timeframe='1m', limit=500)
df_b = pd.DataFrame(b, columns=['t','o','h','l','c','v'])
merged = df_a.merge(df_b, on='t', suffixes=('_bin', '_kr'), how='inner')
merged['close_diff_bps'] = 10000*(merged['c_bin']-merged['c_kr'])/merged[['c_bin','c_kr']].mean(axis=1)
print(merged[['t','c_bin','c_kr','close_diff_bps']].tail(10))
```

Expect tiny `close_diff_bps` most of the time; large, persistent differences = data issue.

---

# C) Hummingbot alignment (no sim, spot-only, safe start)

1. **Confirm image & containers**

```bash
docker pull hummingbot/hummingbot:latest
docker run --rm -it hummingbot/hummingbot:latest --version
docker ps | grep -i hummingbot || true
```

2. **Param autopilot** (ATR/liquidity → spread/refresh/size) – run every 30–60s

```python
# hb_autopilot.py  (outputs suggested params JSON you then apply)
import ccxt, os, json
PAIR=os.getenv('PAIR','BTC/USDT')
ex=ccxt.binance()
ticker=ex.fetch_ticker(PAIR)
orderbook=ex.fetch_order_book(PAIR, 50)
best_spread_bps = 10000*(orderbook['asks'][0][0]-orderbook['bids'][0][0])/((orderbook['asks'][0][0]+orderbook['bids'][0][0])/2)
liq_rank = min(1.0, max(0, (50-best_spread_bps)/50)) # rough proxy
ATRpct_rank = 0.4 # plug your computed ATR% rank here (0..1)
params = {
  "bid_spread_bps": int(max(6, min(35, 8 + 3*ATRpct_rank*10))),
  "ask_spread_bps": int(max(6, min(35, 9 + 3*ATRpct_rank*10))),
  "order_refresh_s": int(max(15, min(60, 50 - 25*liq_rank))),
  "quote_size_quote":  max(50, min(1500, 200 * (1-ATRpct_rank/2)))
}
print(json.dumps(params, indent=2))
```

3. **HB safe probes (no fill)**: configure **postOnly** with a price far from mid; cancel immediately.
4. **HB micro live**: $5 notional after human `CONFIRM`, then cancel remainder.
5. Enable **kill-switches**: pause when spread < maker fee × 1.5, WS gap > 5s, or latency > SLA.

---

# D) PnL & fees truth (daily statement)

* Pull **fills from exchanges** (real trades), compute realized/unrealized PnL with **actual fees**.
* Compare against bot logs; persist a **Daily Statement** (CSV + JSON) signed with a hash.

```python
# pnl_truth.py (sketch)
# 1) fetch closed orders / trades per exchange
# 2) aggregate by day, symbol; apply fees from trade info; compute PnL
# 3) write /data/statements/YYYY-MM-DD.json and CSV; print a SHA256 file hash
```

---

# E) Observability you must have on day one

**Grafana/Prometheus panels**

* Trading: PnL day/week, win-rate(20), avg R, open exposure, DD, slippage bps.
* Execution: order latency p50/p95, reject rate, fill rate.
* Maker: spread capture bps, inventory drift, quote uptime.
* AI: calls by model, premium spend/day, disagreement rate, arbitration outcomes.

**Logs**

* OpenSearch/Kibana (or Loki/Grafana) for exceptions, WS disconnects, cancels, rejections.
* **Langfuse** for LLM traces (free vs premium usage, retries, cost envelopes).

---

# F) Production standards (quick mapping)

This is not legal advice; it’s a pragmatic control map you can actually pass:

* **ISO 27001** (security):
  Access control (Vault + least privilege), Crypto controls (TLS, at-rest keys), Ops security (patches, Docker image scans via Syft/Grype), Logging/monitoring (Grafana/ELK), Supplier mgmt (exchanges, OpenRouter).
* **CIS Ubuntu Benchmarks**:
  UFW, fail2ban/CrowdSec, minimal packages, non-root containers, automatic security updates.
* **Algo governance (MiFID-style RTS 6, adapted)**:
  Pre-trade controls (position caps, notional caps), Kill-switch (drawdown/slippage), Testing (walk-forward, canary), Record-keeping (order/decision payloads, hashes), Capacity/latency monitoring.
* **Business continuity**:
  Backups (Timescale/ClickHouse snapshots), restore test, “degraded mode” (pause trading, keep monitoring).
* **Financial controls**:
  Daily statement, independent PnL recompute, fee reconciliation, maker/taker path logging.

---

# G) Go/No-Go & controlled start

## Go/No-Go checklist (must all be ✅)

* ✅ `lyra_commission.py` OK on all chosen exchanges: spot mode, time-drift OK, fees captured, **post-only probes placed & canceled**.
* ✅ **Keys rotated**, stored in Vault/.env; no secrets in git (`gitleaks` clean).
* ✅ Grafana live with panels above; alerts wired to Telegram.
* ✅ AI router: **free-first**, premium budget set (e.g., $15/day), human confirmation gate on.
* ✅ HB runs with **postOnly** safe config; autopilot script producing sane spreads.
* ✅ Cross-source OHLCV sanity passes.
* ✅ PnL truth script produces a **signed** daily statement.
* ✅ Risk rails enforced in code (0.5–1.0% risk, max 3 positions, daily stop −3R).

## Controlled start sequence (real, no sim)

1. **TRADING_ENABLED=false**. Run **post-only probes** per exchange/pair; confirm cancellations.
2. Flip **TRADING_ENABLED=true**, but **require human `CONFIRM`**.
3. Place **one** $5 micro buy and $5 micro sell (on your deepest pair). Confirm fills, cancel remainder.
4. Observe metrics 60–120 min. If slippage bps > threshold or rejects > X%, **rollback** (disable trading).
5. Enable **one strategy** (e.g., confluence swing or single HB MM instance) on **one pair**.
6. Let it run 24–48h with canary size. Review PnL truth, fees, spread capture, latency.
7. Scale cautiously (one more pair/strategy at a time), never breaching risk rails.

---

## What I can deliver next (fast to drop in)

* **The 3 Python utilities above** already get you >80% of commissioning proof:
  `lyra_commission.py`, `ohlcv_truth.py`, `hb_autopilot.py`.
* **A minimal router** that refuses any job without `CONFIRM=true`, refuses if exchange mode ≠ spot, and clamps size by policy.
* **n8n flow** JSON: TradingView → schema validate → Risk Gate → Exec → Telegram confirm.
* **Grafana JSON** dashboards (PnL/risk/latency/AI usage).
* **OPA policies** (YAML/rego) for max notional, time windows, venue allowlist.

Say “bundle it” and I’ll package these as a ready-to-drop folder tree (`services/ agents/ ops/ dashboards/`) with sane defaults and `.env.example`. You paste secrets, run the scripts, and each step proves—**in reality**—that LYRA is safe, spot-only, and truly live.


1. **Confirm** you want me to **lock spot-only** and stage Hummingbot strategies **quote-only** first (no fills).
2. I’ll output a **tiny commissioning runner** (one bash + one python) that plugs into your 8081 dashboard and requires your **CONFIRM LIVE** click before each rung.
3. Once Rungs A–C show all green on your Grafana + 8081, you can **enable micro-live** (D/E) pair by pair.

That gives you an **AI-controlled, human-confirmed, fee-aware** go-live path—no cannibalisation, no surprises, just small, provable steps to production.
