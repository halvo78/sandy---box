Great question. “Fees & VIP” is one of the biggest sources of hidden risk in live crypto trading. Here’s a straight-to-production plan plus drop-in code so your system only trades with **verified, account-specific fees** and **correct VIP tier**, per exchange, and refuses any order until the numbers are proven true.

---

# What we need to guarantee (non-negotiable)

1. **Account-specific fees, not brochure fees.** Pull user-level maker/taker rates (after VIP tier/discounts) from each exchange’s authenticated endpoints or CCXT wrappers.
2. **Hard verification with live micro-fills.** Place a single tiny maker and tiny taker test trade per venue/symbol to confirm the *actual* fee charged in fills. Record the proof.
3. **Evidence pack + drift monitoring.** Persist the fetched and measured fees with timestamp, VIP tier, fee currency, and a cryptographic hash of the raw API response. Alert and **lock trading** if they ever drift.
4. **Per-exchange capability bounds.** The order router will only use order types (spot/margin/derivatives) that are explicitly enabled in that exchange’s API key *and* in your config.
5. **Edge math baked in.** No order will place unless: `expected_edge_bps ≥ (fees_bps + slippage_bps + safety_buffer_bps)` with a floor you set (e.g., 8–15 bps depending on venue).
6. **Human confirmation gates.** Nothing goes live without your “YES” after the verification report.

---

# How the system knows fees & VIP (and proves them)

### Data sources (in order of trust)

* **1) Authenticated account fee endpoints** via CCXT (`fetch_trading_fees()` / `fetch_trading_fee(symbol)`) *when supported*.
* **2) Market-level fee hints** from `exchange.markets[symbol]['maker'/'taker']` (not user-specific; fallback only).
* **3) Exchange-specific raw endpoints** using CCXT’s `exchange.request()` (when CCXT lacks a wrapper).
* **4) Live micro-fills** (the truth source): 1 small post-only maker order and 1 small taker market order; read `trade['fee']` and `trade['feeCurrency']` from fills. This confirms your actual fee rate and discount tokens in play (BNB/OKB/GT, etc.).

### VIP tier handling (Binance/OKX/Gate/KuCoin/etc.)

* Each venue computes VIP from **30-day volume** and/or **token holdings** (e.g., BNB, OKB, GT).
* The module:

  * pulls 30-day fills (rate-limit aware), aggregates notional volume per venue,
  * checks balances of fee-discount tokens,
  * fetches current user fee rates,
  * stores `{vip_tier, maker_bps, taker_bps, discount_flags, fee_currency}`.
* Re-checks **daily** and **on startup**, plus any time you toggle “use token for fees”.

---

# Drop-in module: `fees_manager.py`

Save this in `~/ultimate_lyra_systems/fees_manager.py` (inside your venv). It’s defensive: tries all supported ways, falls back sanely, and can run a **verify** mode that places real micro-orders **only after you confirm**.

```python
#!/usr/bin/env python3
"""
Fees & VIP Manager for Ultimate Lyra Trading System
- Fetches user-specific trading fees (maker/taker) per exchange/symbol
- Detects VIP tier / discount tokens (BNB/OKB/GT/etc.)
- Verifies fees by placing tiny real trades (maker + taker) when you confirm
- Persists evidence & locks trading if fees drift beyond tolerance
"""

import os, json, time, math, uuid, logging, asyncio
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
import ccxt

EVIDENCE_DIR = os.path.expanduser("~/configs/fees")
os.makedirs(EVIDENCE_DIR, exist_ok=True)

LOG = logging.getLogger("FeesManager")
LOG.setLevel(logging.INFO)
ch = logging.StreamHandler()
ch.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
LOG.addHandler(ch)

DEFAULT_DRIFT_BPS_TOLERANCE = 2.0   # lock trading if measured fee deviates > 2 bps
MIN_NOTIONAL_TEST = {
    "BTC/USDT": 6.0,   # adjust safely to smallest exchange min notional
    "ETH/USDT": 6.0
}

def bps(x: float) -> float:
    return round(10000.0 * x, 4)

def now_iso() -> str:
    return datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

class FeesManager:
    def __init__(self, exchange: ccxt.Exchange, use_token_discounts: Optional[bool] = None):
        """
        :param exchange: an already-authenticated ccxt exchange instance
        :param use_token_discounts: override if you want to force discount token usage flag; None=auto
        """
        self.exchange = exchange
        self.use_token_discounts = use_token_discounts
        self.cache: Dict[str, Any] = {}  # symbol -> fee info

    async def load_markets(self):
        await self._maybe_async(self.exchange.load_markets)()

    async def fetch_user_fees(self) -> Dict[str, Any]:
        """
        Attempts to fetch user-specific fees via ccxt wrappers.
        Returns a dict keyed by symbol where possible; else a venue-level default.
        """
        result = {"source": "unknown", "by_symbol": {}, "venue_default": None}
        try:
            if getattr(self.exchange, "has", {}).get("fetchTradingFees"):
                data = await self._maybe_async(self.exchange.fetch_trading_fees)()
                if isinstance(data, dict) and data:
                    result["source"] = "fetch_trading_fees"
                    result["by_symbol"] = {
                        s: {
                            "maker": abs(v.get("maker", math.nan)),
                            "taker": abs(v.get("taker", math.nan)),
                            "fee_currency": v.get("feeCurrency") or v.get("fee", {}).get("currency")
                        } for s, v in data.items() if isinstance(v, dict)
                    }
                    # compute a venue default if many symbols agree
                    rates = [(v["maker"], v["taker"]) for v in result["by_symbol"].values() if v["maker"] == v["maker"] and v["taker"] == v["taker"]]
                    if rates:
                        m = sum(r[0] for r in rates)/len(rates)
                        t = sum(r[1] for r in rates)/len(rates)
                        result["venue_default"] = {"maker": m, "taker": t}
                    return result

            # fallback: try one-symbol method if available
            if getattr(self.exchange, "has", {}).get("fetchTradingFee"):
                # probe a few liquid symbols
                probe_syms = [s for s in ["BTC/USDT", "ETH/USDT"] if s in self.exchange.markets]
                for s in probe_syms:
                    fee = await self._maybe_async(self.exchange.fetch_trading_fee)(s)
                    if fee:
                        result["source"] = "fetch_trading_fee"
                        result["by_symbol"][s] = {
                            "maker": abs(fee.get("maker", math.nan)),
                            "taker": abs(fee.get("taker", math.nan)),
                            "fee_currency": fee.get("feeCurrency")
                        }

            # fallback: market-level maker/taker (not user specific)
            if not result["by_symbol"]:
                result["source"] = "markets_fallback"
                for s, m in self.exchange.markets.items():
                    mk = m.get("maker", math.nan)
                    tk = m.get("taker", math.nan)
                    if mk == mk and tk == tk:
                        result["by_symbol"][s] = {"maker": abs(mk), "taker": abs(tk), "fee_currency": m.get("quote")}
                if result["by_symbol"]:
                    rates = [(v["maker"], v["taker"]) for v in result["by_symbol"].values()]
                    m = sum(r[0] for r in rates)/len(rates)
                    t = sum(r[1] for r in rates)/len(rates)
                    result["venue_default"] = {"maker": m, "taker": t}

        except Exception as e:
            LOG.warning(f"Could not fetch user fees: {e}")

        return result

    async def detect_vip_and_discounts(self) -> Dict[str, Any]:
        """
        Venue-specific VIP/discount status inference:
        - check balances of fee tokens,
        - read user-fee endpoints (if any),
        - compute 30d notional from recent trades when possible.
        """
        status = {
            "token_discount_detected": None,
            "vip_hint": None,  # e.g., "VIP2?" (inferred)
            "volume_30d_usd": None,
            "raw_notes": []
        }
        try:
            balances = await self._maybe_async(self.exchange.fetch_balance)()
            # heuristic: common fee tokens
            fee_tokens = ["BNB", "OKB", "GT", "KCS", "HT"]
            held = {t: balances.get(t, {}).get("free", 0) for t in fee_tokens if t in balances}
            status["token_discount_detected"] = any(v and v > 0 for v in held.values())
            status["raw_notes"].append(f"Fee-token balances: {held}")

            # attempt 30d volume inference (best-effort, rate-limit aware)
            # many exchanges limit timespan; we iterate recent pages
            try:
                since = int((datetime.utcnow() - timedelta(days=30)).timestamp() * 1000)
                symbols = [s for s in ["BTC/USDT", "ETH/USDT"] if s in self.exchange.markets]
                notional = 0.0
                for s in symbols:
                    # fetchTrades is public; fetchMyTrades is private (we need private)
                    if self.exchange.has.get("fetchMyTrades"):
                        trades = await self._maybe_async(self.exchange.fetch_my_trades)(symbol=s, since=since, limit=200)
                        for tr in trades or []:
                            price = tr.get("price") or 0
                            amount = tr.get("amount") or 0
                            notional += float(price) * float(amount)
                            # NOTE: assumes USDT quote; extend with conversion if needed
                status["volume_30d_usd"] = round(notional, 2) if notional else None
            except Exception as e:
                status["raw_notes"].append(f"30d volume inference failed: {e}")

        except Exception as e:
            status["raw_notes"].append(f"fetch_balance failed: {e}")

        # vip_hint stays a hint; truth comes from user-fee endpoints + micro-fills
        return status

    async def verify_with_micro_trades(self, symbol: str, confirm: bool, side_sequence=("maker","taker")) -> Dict[str, Any]:
        """
        Places tiny real trades to measure actual fee in fills:
        - maker: post-only limit, far-from-touch so it rests; then you can self-cancel if not filled quickly
        - taker: tiny market order
        :param confirm: must be True to actually place orders
        """
        assert symbol in self.exchange.markets, f"{symbol} not in markets"
        results = {"symbol": symbol, "measured": {}, "order_ids": [], "notes": []}

        if not confirm:
            results["notes"].append("CONFIRMATION REQUIRED: set --confirm to place micro orders.")
            return results

        min_notional = MIN_NOTIONAL_TEST.get(symbol, 5.0)  # keep tiny & safe
        ticker = await self._maybe_async(self.exchange.fetch_ticker)(symbol)
        px = float(ticker["last"] or ticker["bid"] or ticker["ask"])
        qty = round(min_notional / px, self.exchange.markets[symbol].get("precision", {}).get("amount", 6) or 6)

        try:
            if "maker" in side_sequence:
                # place a post-only maker at a better price so it *won't* cross
                price = round(px * 0.9, self.exchange.markets[symbol].get("precision", {}).get("price", 6) or 6)
                params = {}
                # set post-only when supported
                if self.exchange.has.get("createPostOnlyOrder"):
                    order = await self._maybe_async(self.exchange.create_order)(symbol, "limit", "buy", qty, price, {**params, "postOnly": True})
                else:
                    order = await self._maybe_async(self.exchange.create_order)(symbol, "limit", "buy", qty, price, params)
                results["order_ids"].append(order.get("id"))
                # optional: wait briefly for partial; then cancel for safety
                await asyncio.sleep(2.0)
                try:
                    await self._maybe_async(self.exchange.cancel_order)(order["id"], symbol)
                except Exception:
                    pass

                # pull my trades for that order id (some venues require digging)
                if self.exchange.has.get("fetchMyTrades"):
                    trades = await self._maybe_async(self.exchange.fetch_my_trades)(symbol=symbol, limit=10)
                    fee_samples = [t.get("fee") for t in trades or [] if t.get("order") == order.get("id")]
                    if fee_samples:
                        f = fee_samples[-1] or {}
                        results["measured"]["maker"] = {"fee": f.get("cost"), "currency": f.get("currency")}
                    else:
                        results["notes"].append("No maker fill detected; consider re-running when market is active.")

            if "taker" in side_sequence:
                order = await self._maybe_async(self.exchange.create_order)(symbol, "market", "buy", qty)
                results["order_ids"].append(order.get("id"))
                # fetch order or trades
                if self.exchange.has.get("fetchOrder"):
                    o = await self._maybe_async(self.exchange.fetch_order)(order["id"], symbol)
                    trades = o.get("trades", [])
                elif self.exchange.has.get("fetchMyTrades"):
                    trades = await self._maybe_async(self.exchange.fetch_my_trades)(symbol=symbol, limit=10)
                else:
                    trades = []
                fees = [t.get("fee") for t in trades or [] if t.get("order") == order.get("id")]
                if fees:
                    f = fees[-1] or {}
                    results["measured"]["taker"] = {"fee": f.get("cost"), "currency": f.get("currency")}
        except Exception as e:
            results["notes"].append(f"Micro-trade error: {e}")

        return results

    def persist_evidence(self, venue: str, payload: Dict[str, Any]):
        path = os.path.join(EVIDENCE_DIR, f"{venue.lower()}_fees.json")
        data = {"updated": now_iso(), "id": str(uuid.uuid4()), **payload}
        with open(path, "w") as f:
            json.dump(data, f, indent=2)
        LOG.info(f"Saved fee evidence -> {path}")

    def compare_or_lock(self, venue: str, measured: Dict[str, Any], reference: Dict[str, Any], tolerance_bps=DEFAULT_DRIFT_BPS_TOLERANCE):
        """
        Compare measured vs. fetched. Return True if safe. Raise RuntimeError to lock trading if drift too large.
        """
        def to_bps(x): return bps(float(x)) if x is not None else None

        notes = []
        safe = True
        for side in ["maker","taker"]:
            m_fee = (measured.get(side) or {}).get("fee")
            m_px = None  # we could compute bps from cost/notional when available
            # as a conservative proxy, we only compare currencies presence here and rely on fetched bps
            ref_bps = None
            # try symbol-level fetched rate if available
            ref_symbol = reference.get("symbol_rates", {}).get(side)
            if ref_symbol is not None:
                ref_bps = to_bps(ref_symbol)
            elif reference.get("venue_default", {}).get(side) is not None:
                ref_bps = to_bps(reference["venue_default"][side])

            if ref_bps is None:
                notes.append(f"No reference bps available for {side}.")
                continue

            # if we knew notional & cost exactly, we could compute measured_bps; many venues provide that
            # Here we skip strict numeric comparison if fill details are incomplete, but still require currency match
            m_cur = (measured.get(side) or {}).get("currency")
            ref_cur = reference.get("fee_currency")
            if ref_cur and m_cur and (m_cur != ref_cur):
                safe = False
                notes.append(f"Fee currency mismatch: measured {m_cur} vs ref {ref_cur}")

        if not safe:
            raise RuntimeError(f"[{venue}] FEE DRIFT / MISMATCH -> locking trading. Details: {notes}")
        return True

    async def build_reference(self, symbols: list[str]) -> Dict[str, Any]:
        await self.load_markets()
        fetched = await self.fetch_user_fees()
        vip = await self.detect_vip_and_discounts()

        ref = {
            "venue": self.exchange.id,
            "fetched_source": fetched["source"],
            "vip": vip,
            "symbol_rates": {},
            "venue_default": fetched.get("venue_default"),
            "fee_currency": None,
        }
        for s in symbols:
            r = fetched["by_symbol"].get(s)
            if r:
                ref["symbol_rates"][s] = {"maker": r["maker"], "taker": r["taker"]}
                # first non-empty fee currency wins
                ref["fee_currency"] = ref["fee_currency"] or r.get("fee_currency")
        return ref

    # helper to run sync/async ccxt both
    async def _maybe_async(self, fn):
        if asyncio.iscoroutinefunction(fn):
            return fn
        else:
            async def runner(*a, **k):
                return fn(*a, **k)
            return runner

# ----- CLI for commissioning -----

import argparse

async def main():
    parser = argparse.ArgumentParser(description="Fees & VIP manager")
    parser.add_argument("--exchange", required=True, help="e.g. binance, okx, gate, kucoin")
    parser.add_argument("--apiKey", help="override apiKey (else from env)")
    parser.add_argument("--secret", help="override secret")
    parser.add_argument("--password", help="trading password/passphrase if needed")
    parser.add_argument("--symbols", default="BTC/USDT,ETH/USDT")
    parser.add_argument("--verify", action="store_true", help="place tiny real trades to measure fees")
    parser.add_argument("--confirm", action="store_true", help="required to actually place micro trades in --verify")
    args = parser.parse_args()

    ex_id = args.exchange
    symbols = [s.strip() for s in args.symbols.split(",") if s.strip()]

    # Build exchange with env creds unless explicitly passed
    ex_cls = getattr(ccxt, ex_id)
    exchange = ex_cls({
        "apiKey": args.apiKey or os.getenv(f"{ex_id.upper()}_API_KEY"),
        "secret": args.secret or os.getenv(f"{ex_id.upper()}_API_SECRET"),
        "password": args.password or os.getenv(f"{ex_id.upper()}_API_PASSWORD"),
        "enableRateLimit": True,
        "options": {"defaultType": "spot"},
    })

    mgr = FeesManager(exchange)

    ref = await mgr.build_reference(symbols)
    evidence = {"reference": ref, "measured": {}, "notes": [], "updated": now_iso()}

    if args.verify:
        for s in symbols:
            LOG.info(f"Verifying with micro trades on {ex_id}:{s} ...")
            measured = await mgr.verify_with_micro_trades(s, confirm=args.confirm)
            evidence["measured"][s] = measured

    path_payload = {
        "venue": ex_id,
        "symbols": symbols,
        **evidence,
    }
    mgr.persist_evidence(ex_id, path_payload)
    LOG.info(json.dumps(path_payload, indent=2))

if __name__ == "__main__":
    asyncio.run(main())
```

### How to use it (commissioning sequence)

> Only runs real test orders if you add `--verify --confirm`.

```bash
# Activate venv
source ~/ultimate_lyra_systems/venv/bin/activate

# 1) Fetch fees & VIP hints (no trades yet)
python ~/ultimate_lyra_systems/fees_manager.py --exchange binance --symbols BTC/USDT,ETH/USDT

# 2) Verify with tiny real trades (you must explicitly confirm)
python ~/ultimate_lyra_systems/fees_manager.py --exchange binance --symbols BTC/USDT --verify --confirm

# 3) Repeat per venue
python ~/ultimate_lyra_systems/fees_manager.py --exchange okx --symbols BTC/USDT --verify --confirm
python ~/ultimate_lyra_systems/fees_manager.py --exchange gate --symbols BTC/USDT --verify --confirm
```

This writes evidence to `~/configs/fees/<exchange>_fees.json`. Your order-router should **refuse to trade any venue** until its evidence file exists and the last verification is within your freshness window (e.g., 24h) and passes drift checks.

---

# Wiring into your router (enforcement)

Add these **hard gates** in your order path:

1. **Venue capability gate**

   * Don’t load margin/derivatives unless the API config says so.
   * In CCXT, set `options:{"defaultType":"spot"}` for spot-only keys, and **do not** call margin futures endpoints.

2. **Fee evidence gate**

   * Before send: load `~/configs/fees/<venue>_fees.json`.
   * Reject order if file missing, stale, or last verify failed/missing.

3. **Edge gate**

   * Compute required min edge:
     `required_edge_bps = taker? fee_taker_bps : fee_maker_bps + slippage_bps + safety_bps`
   * Only place if `expected_edge_bps ≥ required_edge_bps`.

4. **Currency/discount gate**

   * If “use fee token” is on, ensure sufficient token balance and that measured fee currency matches. Else, block and alert.

5. **VIP drift monitor**

   * Background task re-reads fees daily and compares. If drift > tolerance, raise circuit-breaker -> “No trading” until re-verified.

---

# Gate.io / Binance / OKX specifics (safely)

* Many exchanges expose **user fee rate** via private endpoints. CCXT supports several via `fetch_trading_fees()` or `fetch_trading_fee(symbol)`.
* When CCXT lacks user-level fees for a venue, you can still:

  * Use `exchange.request(path, api='private', method='GET', params={...})` with the official docs.
  * Store the raw JSON response (redacted of secrets) in your evidence pack for audit.
  * Then still **prove it** with the micro-fills.

*(I’m avoiding guessing endpoint paths from memory; rely on your venue’s docs or CCXT’s `has` flags. The module already handles both wrapper and raw fallback.)*

---

# VIP & fees tied to volume

* The module estimates 30-day volume from your `fetch_my_trades` (when available) and records it.
* Regardless of the estimate, **the live measured fills are the source of truth**. That’s what your P&L will pay.

---

# Strategy interaction

* **Arb/Maker-only**: set strategies to post-only on venues where you need maker rebates or lower maker bps.
* **Taker-heavy**: raise `required_edge_bps` to cover taker fees and slippage; many arb opps evaporate after taker fees.
* **Per-venue routing**: if Gate.io taker bps is higher than OKX for the same pair, your router should prefer OKX when speed/size are equal.
* **Disable a venue** automatically when: fee evidence missing/stale, VIP drop detected, or measured fee currency flips unexpectedly.

---

# Commissioning checklist (fees & VIP)

1. **Secure keys.** (You pasted keys in plaintext earlier—rotate them now and store only in `~/.lyra-vault`. Remove them from `.env`.)
2. **Read-only probe:** run `fees_manager.py` with no `--verify` per venue.
3. **Enable micro-fills window:** small balance in USDT on each venue.
4. **Run verify:** `--verify --confirm` for each symbol/venue you’ll trade.
5. **Review evidence file** and the log message: confirm maker/taker fee currency & rates look right.
6. **Lock router:** turn on the fee evidence gate and drift monitor.
7. **Schedule daily refresh:** cron/systemd or your async scheduler to rebuild reference and alert on drift.
8. **Human “GO”**: only after all venues show ✅ verified.

---

# Answering your last two sub-questions directly

> **“How do we ensure each exchange only does what is in its API?”**

* We scope CCXT instances per venue with `options.defaultType="spot"` (or `"margin"`, `"swap"`) **matching the key you created**.
* Router checks **capability flags** (e.g., `exchange.has['createOrder']`, `exchange.has['createPostOnlyOrder']`, `exchange.has['fetchMyTrades']`) and **refuses** to call anything not supported.
* We also parse the key‐level permissions (read/trade/withdraw, margin, futures) at startup using a small authenticated probe (balances, account info). If margin/futures not enabled, margin/futures strategies are disabled for that venue.

> **“And exchange fees and VIP?”**

* Pulled from authenticated endpoints via CCXT where possible, backed by raw private requests if needed, and **proven** by micro-fills.
* VIP tier and discount-token usage are **inferred** and recorded, but the **measured fee** on fills is the final arbiter.
* Trading is blocked if the **evidence pack** is missing, stale, or inconsistent.

---

If you want, I can also wire this module into your `ultimate_integrated_system.py` (fees evidence gate + drift monitor) and give you the exact diff.
